/*
ѕример 7
ƒвоичный поиск числа в отсортированном массиве
*/
#include <iostream>

using namespace std;

/*	
	b - индекс левой границы массива
	e - индекс правой границы массива
	key - искомый элемент массива 
*/
int Binp(int a[], int b, int e, int key)	
{
	if (key > a[e] || key < a[b]) return -1;	// неправильно заданы границы, 
												// в заданных границах числа нет
	
	if (b == e) return b;	// лева¤ и права¤ граница совпали, 
							// и это и есть индекс искомого элемента
	int m = (b + e) / 2;
	if (a[m] == key) return m;	// число key находитс¤ на месте m
	else if (a[m] > key) Binp(a, b, m - 1, key);	// число key находитс¤ в левой половине
													// следовательно сдвигаем правую границу e
	else/*(a[m] < key)*/ Binp(a, m + 1, e, key);	// число key находитс¤ в правой половине
													// следовательно сдвигаем левую границу b		
}

int main()
{
	const int N = 12;
	//			 0	1  2  3  4  5  6  7  8  9   10  11 
	int a[N] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

	int key = 2;
	// ¬ызов рекурсивной функции
	cout << "Index of " << key << " = " << Binp(a, 5, 11, key) << endl;
	cout << endl;
	// ѕроверка всего массива
	for (int i = 0; i < N -1; i++)
	{
		cout << "Index of " << a[i] << " = " << Binp(a, 0, 11, a[i]) << endl;
	}
	return 0;
}
