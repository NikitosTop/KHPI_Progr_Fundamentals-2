/*
Пример 7.1
Двоичный поиск числа в отсортированном массиве
*/
#include <iostream>

using namespace std;

/*
	b - индекс левой границы массива
	e - индекс правой границы массива
	key - искомый элемент массива
*/
int Binp(int a[], int b, int e, int key)
{
	if (b == e) return -1;	// лева¤ и права¤ граница совпали, 
							// числа в указанном диапазоне нет
	int m = (b + e) / 2;
	if (a[m] == key) return m;	// число key находится на месте m
	else if (a[m] > key) Binp(a, b, m, key);	// число key находится в левой половине
													// следовательно сдвигаем правую границу e
	else/*(a[m] < key)*/ Binp(a, m, e, key);	// число key находится в правой половине
													// следовательно сдвигаем левую границу b		
}

int main()
{
	const int N = 12;
	//			 0	1  2  3  4  5  6  7  8  9   10  11 
	int a[N] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 };

	int key = 2;
	// Вызов рекурсивной функции
	cout << "Index of " << key << " = " << Binp(a, 5, 11, key) << endl;
	cout << endl;
	// Проверка всего массива
	for (int i = 0; i < N - 1; i++)
	{
		cout << "Index of " << a[i] << " = " << Binp(a, 0, 11, a[i]) << endl;
	}
	return 0;
}
